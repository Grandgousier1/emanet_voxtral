# .pre-commit-config.yaml - Configuration hooks pre-commit
repos:
  # Hooks standards pre-commit
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
        name: "Supprime espaces en fin de ligne"
      - id: end-of-file-fixer
        name: "Assure nouvelle ligne en fin de fichier"
      - id: check-yaml
        name: "Valide syntaxe YAML"
      - id: check-toml
        name: "Valide syntaxe TOML"
      - id: check-json
        name: "Valide syntaxe JSON"
      - id: check-added-large-files
        name: "V√©rifie taille fichiers"
        args: ['--maxkb=1000']
      - id: check-merge-conflict
        name: "D√©tecte marqueurs merge conflict"
      - id: debug-statements
        name: "D√©tecte statements debug Python"
      - id: check-executables-have-shebangs
        name: "V√©rifie shebangs fichiers ex√©cutables"
      - id: check-shebang-scripts-are-executable
        name: "V√©rifie ex√©cutabilit√© scripts"

  # Black - formatage code
  - repo: https://github.com/psf/black
    rev: 23.7.0
    hooks:
      - id: black
        name: "Black - formatage code Python"
        language_version: python3

  # isort - tri imports
  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        name: "isort - tri imports Python"

  # flake8 - linting
  - repo: https://github.com/pycqa/flake8
    rev: 6.0.0
    hooks:
      - id: flake8
        name: "flake8 - linting Python"
        additional_dependencies: [
          flake8-docstrings,
          flake8-bugbear,
          flake8-comprehensions,
          flake8-simplify,
        ]

  # mypy - v√©rification types
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.4.1
    hooks:
      - id: mypy
        name: "mypy - v√©rification types Python"
        additional_dependencies: [
          types-requests,
          types-PyYAML,
          types-setuptools,
        ]
        # Exclut certains fichiers pour migration progressive
        exclude: ^(tests/|benchmark\.py|validator\.py)

  # bandit - s√©curit√©
  - repo: https://github.com/pycqa/bandit
    rev: 1.7.5
    hooks:
      - id: bandit
        name: "bandit - analyse s√©curit√© Python"
        args: ["-c", "pyproject.toml"]
        exclude: ^tests/

  # Hooks personnalis√©s pour le projet
  - repo: local
    hooks:
      # Validation structure projet
      - id: validate-project-structure
        name: "Valide structure projet"
        entry: python -c "
import sys
from pathlib import Path

required_files = [
    'main.py', 'config.py', 'pyproject.toml', 'README.md',
    'utils/model_utils.py', 'utils/b200_optimizer.py'
]

missing = []
for file in required_files:
    if not Path(file).exists():
        missing.append(file)

if missing:
    print(f'Fichiers manquants: {missing}')
    sys.exit(1)
print('Structure projet OK')
"
        language: python
        pass_filenames: false
        always_run: true

      # Validation imports critiques
      - id: check-critical-imports
        name: "V√©rifie imports critiques"
        entry: python -c "
import ast
import sys
from pathlib import Path

# V√©rifications d'imports dangereux
dangerous_imports = ['os.system', 'subprocess.call', 'eval', 'exec']

def check_file(filepath):
    try:
        with open(filepath, 'r') as f:
            tree = ast.parse(f.read())
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Attribute):
                    call_name = f'{node.func.value.id}.{node.func.attr}' if hasattr(node.func.value, 'id') else str(node.func.attr)
                    if call_name in dangerous_imports:
                        print(f'Import dangereux d√©tect√© dans {filepath}: {call_name}')
                        return False
    except:
        pass
    return True

failed = False
for py_file in Path('.').glob('**/*.py'):
    if '.venv' not in str(py_file) and '__pycache__' not in str(py_file):
        if not check_file(py_file):
            failed = True

if failed:
    sys.exit(1)
print('Imports critiques OK')
"
        language: python
        files: \.py$
        pass_filenames: false

      # Validation configuration B200
      - id: validate-b200-config
        name: "Valide configuration B200"
        entry: python -c "
import sys
from pathlib import Path

try:
    # V√©rifie que les optimisations B200 sont pr√©sentes
    b200_file = Path('utils/b200_optimizer.py')
    if not b200_file.exists():
        print('Fichier B200 optimizer manquant')
        sys.exit(1)
    
    content = b200_file.read_text()
    required_features = [
        'torch.compile', 'bfloat16', 'B200Config', 
        'optimize_model', 'B200BatchProcessor'
    ]
    
    missing = []
    for feature in required_features:
        if feature not in content:
            missing.append(feature)
    
    if missing:
        print(f'Features B200 manquantes: {missing}')
        sys.exit(1)
    
    print('Configuration B200 OK')
except Exception as e:
    print(f'Erreur validation B200: {e}')
    sys.exit(1)
"
        language: python
        pass_filenames: false
        always_run: true

      # Tests rapides
      - id: quick-tests
        name: "Tests rapides"
        entry: python -c "
import subprocess
import sys

try:
    # Lance tests unitaires rapides
    result = subprocess.run([
        sys.executable, '-m', 'pytest', 
        'tests/', '-v', '--tb=short', 
        '-m', 'not slow and not gpu',
        '--maxfail=3'
    ], capture_output=True, text=True, timeout=60)
    
    if result.returncode != 0:
        print('Tests rapides √©chou√©s:')
        print(result.stdout)
        print(result.stderr)
        sys.exit(1)
    
    print('Tests rapides OK')
except subprocess.TimeoutExpired:
    print('Tests rapides timeout')
    sys.exit(1)
except FileNotFoundError:
    print('pytest non disponible, tests ignor√©s')
"
        language: python
        pass_filenames: false
        # Ne lance que si des fichiers Python sont modifi√©s
        files: \.py$

      # V√©rification taille des fonctions
      - id: check-function-length
        name: "V√©rifier taille fonctions (<50 lignes)"
        entry: python -c "
import ast
import sys
from pathlib import Path

def check_function_length(filepath, max_lines=50):
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()
            tree = ast.parse(''.join(lines))
        
        violations = []
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                # Skip private/magic methods and property getters/setters
                if (node.name.startswith('__') or 
                    any(d.id in ['property', 'setter', 'getter'] 
                        for d in node.decorator_list 
                        if isinstance(d, ast.Name))):
                    continue
                
                func_start = node.lineno
                func_end = node.end_lineno if hasattr(node, 'end_lineno') else func_start
                func_lines = func_end - func_start + 1
                
                if func_lines > max_lines:
                    violations.append(f'{filepath}:{func_start} - {node.name}() ({func_lines} lignes > {max_lines})')
        
        return violations
    except Exception as e:
        return [f'{filepath}: Erreur parsing - {e}']

violations = []
for filepath in sys.argv[1:]:
    if Path(filepath).suffix == '.py':
        violations.extend(check_function_length(filepath))

if violations:
    print('‚ö†Ô∏è Fonctions trop longues d√©tect√©es:')
    for violation in violations[:10]:  # Limite √† 10 pour lisibilit√©
        print(f'  {violation}')
    if len(violations) > 10:
        print(f'  ... et {len(violations) - 10} autres')
    print()
    print('üí° Conseil: D√©composez ces fonctions en sous-fonctions plus petites')
    print('   pour am√©liorer la lisibilit√© et la testabilit√©.')
    sys.exit(1)
else:
    print('‚úÖ Taille des fonctions OK')
"
        language: python
        files: \.py$

# Configuration g√©n√©rale
default_language_version:
  python: python3

# √âtapes √† ignorer pour certains types de commits
ci:
  autofix_commit_msg: |
    [pre-commit.ci] auto fixes from pre-commit hooks

    for more information, see https://pre-commit.ci
  autofix_prs: true
  autoupdate_branch: ''
  autoupdate_commit_msg: '[pre-commit.ci] pre-commit autoupdate'
  autoupdate_schedule: weekly
  skip: [quick-tests]  # Skip tests on CI (too slow)
  submodules: false